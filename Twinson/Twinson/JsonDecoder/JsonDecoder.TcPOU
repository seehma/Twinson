<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="JsonDecoder" Id="{c2bd40df-6169-4fb7-bccc-6fe5055a7ea3}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'conditionalshow_all_locals'}
{attribute 'no_explicit_call' := 'JsonDecoder is a class, do not call'}
FUNCTION_BLOCK JsonDecoder
VAR
  _jsonPtr : POINTER TO BYTE;
  _memPtr : POINTER TO BYTE;
  _key : STRING;
  _keyPtr : POINTER TO BYTE := ADR(_key);
  _assigments : ARRAY[0..ParameterList.MaxJsonAssignments] OF JsonAssignment;
  _assigmentsPtr : POINTER TO JsonAssignment := ADR(_assigments);
  _el : JsonElementType;
END_VAR
VAR_OUTPUT
  Error : BOOL;
  ErrorMessage : STRING;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Abort" Id="{151abc50-572e-41de-9235-590a6cc2cb06}">
      <Declaration><![CDATA[METHOD Abort
VAR_INPUT
  errorMessage : STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.ErrorMessage := errorMessage;
THIS^.Error := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddAssignment" Id="{b4920f3e-12a7-4d6b-b494-42db676d6673}">
      <Declaration><![CDATA[METHOD AddAssignment
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_assigmentsPtr^.key := _key;
_assigmentsPtr^.valueType := _el;
_assigmentsPtr^.startPtr := _memPtr;
_assigmentsPtr^.endPtr := _jsonPtr - 1;
_assigmentsPtr := _assigmentsPtr + SIZEOF(JsonAssignment);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddToKey" Id="{489314ba-53d4-43bd-a926-ca72da578204}">
      <Declaration><![CDATA[METHOD AddToKey]]></Declaration>
      <Implementation>
        <ST><![CDATA[WHILE _memPtr <> _jsonPtr
DO
  _keyPtr^ := _memPtr^;
  _keyPtr := _keyPtr + 1;
  _memPtr := _memPtr + 1;
END_WHILE
_keyPtr^ := 0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="DecodeText" Id="{bd0f2002-7d0a-4d67-a5d7-f7acec12df17}">
      <Declaration><![CDATA[METHOD DecodeText
VAR_INPUT
  json : STRING(ParameterList.MaxJsonLength);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_jsonPtr := ADR(json);
_key := '';
_keyPtr := ADR(_key);
_assigmentsPtr := ADR(_assigments);

Error := FALSE;

WHILE _jsonPtr^ <> 0
DO
  SkipWhitespaces();

  IF GuessElementType() = JsonElementType.Object
  THEN
    ParseObject();
  ELSE
    Abort('Unexpected character');    
  END_IF  
  
  _jsonPtr := _jsonPtr + 1;
END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="GuessElementType" Id="{34940981-ada5-4521-bbcd-34f0ecb406f1}">
      <Declaration><![CDATA[METHOD PRIVATE GuessElementType : JsonElementType
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE _jsonPtr^
OF
  16#22: // "
    GuessElementType := JsonElementType.Strng;
  16#30..16#39, // 0-9
  16#2B, // +
  16#2D, // -
  16#2E, // .
  16#65, // e
  16#45: // E
    GuessElementType := JsonElementType.Number;    
  16#7B: // {
    GuessElementType := JsonElementType.Object;
  16#5B: // [
    GuessElementType := JsonElementType.Arry;
  16#66, // f
  16#74: // t
    GuessElementType := JsonElementType.Boolean;
  16#6E: // n
    GuessElementType := JsonElementType.Null;      
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ParseObject" Id="{d3f57aad-1f9b-4dd9-890f-af9c01be5099}">
      <Declaration><![CDATA[METHOD ParseObject
VAR
  objKeyPtr : POINTER TO BYTE;
  elKeyMemPtr : POINTER TO BYTE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// push key pointer
objKeyPtr := _keyPtr;

// skip {
_jsonPtr := _jsonPtr + 1;
SkipWhitespaces();

REPEAT

  _el := GuessElementType();
  IF _el <> JsonElementType.Strng
  THEN
    Abort('Unexpected character');
    RETURN;    
  END_IF
  
  // push key pointer
  elKeyMemPtr := _keyPtr;
  
  // skip "
  _jsonPtr := _jsonPtr + 1;
  _memPtr := _jsonPtr;
  SkipString();
  
  // chain key
  AddToKey();
  
  // skip " and additional whitespaces
  _jsonPtr := _jsonPtr + 1;
  SkipWhitespaces();
  
  IF _jsonPtr^ <> 16#3A // :
  THEN
    Abort('Expected colon');
    RETURN;
  END_IF
  
  // skip :
  _jsonPtr := _jsonPtr + 1;
  SkipWhitespaces();
  
  _el := GuessElementType();

  CASE _el
  OF
    JsonElementType.Strng:
      // skip " and additional whitespaces
      _jsonPtr := _jsonPtr + 1;
      _memPtr := _jsonPtr;
      SkipString();
      AddAssignment();
      // skip "
      _jsonPtr := _jsonPtr + 1;    
    
    JsonElementType.Number:
      _memPtr := _jsonPtr;
      SkipNumber();
      AddAssignment();
      
    JsonElementType.Object:
      // add . to the key and continue with the next object
      _keyPtr^ := 16#2E;
      _keyPtr := _keyPtr + 1;
      ParseObject();
    
      // remove . from the key
      _keyPtr^ := 0;
      _keyPtr := _keyPtr - 1;
    
    JsonElementType.Arry:
    
      ; // todo
      
    JsonElementType.Boolean:
      _memPtr := _jsonPtr;
      SkipBoolean();
      AddAssignment();
      
    JsonElementType.Null:
      _memPtr := _jsonPtr;
      _jsonPtr := _jsonPtr + 4; // null
      AddAssignment();
  ELSE
    Abort('Unexpected character');
    RETURN;
  END_CASE
  
  SkipWhitespaces();
  IF _jsonPtr^ = 16#2C // ,
  THEN
    _jsonPtr := _jsonPtr + 1; // ,
    // pop key pointer
    _keyPtr := objKeyPtr; 
    _keyPtr^ := 0;
    SkipWhitespaces();      
  END_IF
  
UNTIL _jsonPtr^ = 16#7D OR_ELSE _jsonPtr^ = 0 END_REPEAT // ] or EOF

IF _jsonPtr^ <> 0
THEN
  // skip }
  _jsonPtr := _jsonPtr + 1;
  
  // pop key pointer
  _keyPtr := objKeyPtr; 
  _keyPtr^ := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SkipBoolean" Id="{8891d801-d872-42b4-a283-4d50aacd8df8}">
      <Declaration><![CDATA[METHOD SkipBoolean : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_jsonPtr := _jsonPtr + 4; // true

IF _jsonPtr^ = 16#66 // f
THEN
  _jsonPtr := _jsonPtr + 1; // false
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SkipNumber" Id="{77969f1c-9894-42e4-81b6-8fc4acc31c50}">
      <Declaration><![CDATA[METHOD PRIVATE SkipNumber
VAR
  ch : BYTE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ch := _jsonPtr^;
WHILE (ch >= 16#30 AND_THEN ch <= 16#39) OR_ELSE ch = 16#2B OR_ELSE ch = 16#2D OR_ELSE ch = 16#2E OR_ELSE ch = 16#65 OR_ELSE ch = 16#45
DO
  _jsonPtr := _jsonPtr + 1;
  ch := _jsonPtr^;
END_WHILE ]]></ST>
      </Implementation>
    </Method>
    <Method Name="SkipString" Id="{1acc1bd3-5568-4718-af78-edb71be6e7a9}">
      <Declaration><![CDATA[METHOD PRIVATE SkipString
VAR
  len : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[WHILE _jsonPtr^ <> 16#22
DO
  _jsonPtr := _jsonPtr + 1;
END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="SkipWhitespaces" Id="{eb42f950-84b2-4370-a0c4-aff9ce5ce2f4}">
      <Declaration><![CDATA[METHOD PRIVATE SkipWhitespaces
VAR
  ch : BYTE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ch := _jsonPtr^;
WHILE(ch = 16#20 OR_ELSE ch = 16#12 OR_ELSE ch = 16#15 OR_ELSE ch = 16#11 OR_ELSE ch = 0)
DO
  _jsonPtr := _jsonPtr + 1;
  ch := _jsonPtr^;
END_WHILE]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>